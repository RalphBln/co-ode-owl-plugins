/**
* JJTree file
*/

options {
	VISITOR=true;
  JDK_VERSION = "1.5";
    MULTI=false;
    NODE_PREFIX="OPPL";

   /* DEBUG_PARSER=true; */

}

PARSER_BEGIN(OPPLParser)
package org.coode.oppl.syntax;
import java.io.Reader;
import java.net.URI;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Arrays;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.coode.manchesterowlsyntax.ManchesterOWLSyntaxEditorParser;
import org.coode.oppl.AbstractConstraint;
import org.coode.oppl.InCollectionConstraint;
import org.coode.oppl.InequalityConstraint;
import org.coode.oppl.OPPLAbstractFactory;
import org.coode.oppl.OPPLFactory;
import org.coode.oppl.OPPLQuery;
import org.coode.oppl.OPPLScript;
import org.coode.oppl.exceptions.OPPLException;
import org.coode.oppl.validation.OPPLScriptValidator;
import org.coode.oppl.variablemansyntax.ConstraintSystem;
import org.coode.oppl.variablemansyntax.ExpressionParser;
import org.coode.oppl.variablemansyntax.Variable;
import org.coode.oppl.variablemansyntax.VariableManchesterOWLSyntaxParser;
import org.coode.oppl.variablemansyntax.VariableScope;
import org.coode.oppl.variablemansyntax.VariableScopes;
import org.coode.oppl.variablemansyntax.VariableType;
import org.coode.oppl.variablemansyntax.VariableScopes.Direction;
import org.coode.oppl.variablemansyntax.generated.Attribute;
import org.coode.oppl.variablemansyntax.generated.AbstractCollectionGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.ConcatGeneratedValues;
import org.coode.oppl.variablemansyntax.generated.RegExpGeneratedVariable;
import org.coode.oppl.variablemansyntax.generated.StringGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.GeneratedValue;
import org.coode.oppl.variablemansyntax.generated.GeneratedVariable;
import org.coode.oppl.variablemansyntax.generated.factory.AttributeFactory;
import org.semanticweb.owl.apibinding.OWLManager;
import org.semanticweb.owl.expression.ParserException;
import org.semanticweb.owl.inference.OWLReasoner;
import org.semanticweb.owl.model.AddAxiom;
import org.semanticweb.owl.model.OWLAxiom;
import org.semanticweb.owl.model.OWLAxiomChange;
import org.semanticweb.owl.model.OWLClass;
import org.semanticweb.owl.model.OWLDataProperty;
import org.semanticweb.owl.model.OWLDescription;
import org.semanticweb.owl.model.OWLObject;
import org.semanticweb.owl.model.OWLObjectProperty;
import org.semanticweb.owl.model.OWLOntology;
import org.semanticweb.owl.model.OWLOntologyManager;
import org.semanticweb.owl.model.RemoveAxiom;
import org.semanticweb.owl.model.OWLEntity;

public class OPPLParser {
	private static OWLOntologyManager owlOntologyManager;

	private static OPPLAbstractFactory opplFactory = null;
	private static List completions = new ArrayList();

	private static OWLOntology ontology;
	private static OWLReasoner reasoner;
	private  static OPPLScriptValidator validator=null;

	public static void setOPPLScriptValidator(OPPLScriptValidator validator){
		OPPLParser.validator = validator;
	}

	public static List getCompletions(){
		return completions;
	}

	public static OPPLAbstractFactory getOPPLFactory(){
		if(opplFactory ==null){
			opplFactory = new OPPLFactory(owlOntologyManager, ontology, reasoner);
		}
		return opplFactory;
	}

	public static void setOPPLFactory(OPPLAbstractFactory factory){
		opplFactory = factory;
	}

	public static OWLOntologyManager getOWLOntologyManager(){
		return owlOntologyManager;
	}

	public static void setReasoner(OWLReasoner r){
		reasoner = r;
	}

   public OPPLParser(java.io.InputStream in, OWLOntologyManager m, OWLOntology o, OWLReasoner r){
		this(in);
   		owlOntologyManager = m;
   		ontology = o;
   		reasoner = r;
   }

   	public static void ReInit(Reader reader,
			OWLOntologyManager m, OWLOntology o, OWLReasoner r){
		ReInit(reader);
		owlOntologyManager = m;
		ontology = o;
   		reasoner = r;
	}

   	public OPPLParser(Reader reader, OWLOntologyManager m,
			OWLOntology o, OWLReasoner r) {
		this(reader);
		owlOntologyManager = m;
		ontology = o;
   		reasoner = r;
	}

	public static void main(String args[]) {
    	System.out.println("Reading from standard input...");
    	System.out.print("Enter an expression :");
    	String ontologyPhysicalURI = args[0];
		OWLOntologyManager m = OWLManager.createOWLOntologyManager();
    try {
	  OWLOntology o = m.loadOntology(URI.create(ontologyPhysicalURI));
	  new OPPLParser(System.in, m, o, null);
      OPPLScript n = OPPLParser.Start();
      System.out.println("Thank you.");
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
PARSER_END(OPPLParser)

SKIP :
{" "| "\t"| "\n"| "\r"| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">}
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])?>
|  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}
TOKEN:/*metachars*/
{<REGEXPMETACHAR:["\\","-","$","|","?","*"]>}
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: "?" <NAME> >
| <#NAME:  <LETTER> (<LETTER>|<DIGIT>)*>
|  < #LETTER: ["_","a"-"z","A"-"Z", "\u00e0"-"\u00f9"] >
|  < #DIGIT: ["0"-"9"] >
}

TOKEN[IGNORE_CASE]:/* OPPL FUNCTIONS*/
{	<CREATE:   "create">
	| <CREATEINTERSECTION: "CreateIntersection">
	| <CREATEUNION: "CreateUnion">
	| <MATCH:"Match">
}

TOKEN :/* VARIABLE TYPES*/
{<VARIABLETYPE: "CLASS" | "OBJECTPROPERTY" | "DATAPROPERTY" | "INDIVIDUAL" | "CONSTANT">}


TOKEN[IGNORE_CASE]: /* OPPL SYNTAX*/
{<SELECT: "SELECT"> |<WHERE: "WHERE">| <ASSERTED: "ASSERTED"> | <ADD: "ADD"> | <REMOVE: "REMOVE"> |<BEGIN: "BEGIN"> |<END: "END">}

TOKEN: /*PUNCTUATION*/
{<COMMA:",">
	| <SEMICOLON: ";">
	| <COLON: ":">
	| <OPENPARENTHESYS: "(">
	| <CLOSEDPARENTHESYS: ")">
	| <QUOTE: "\"">
	| <POWER: "^">
	| <OPENCURLYBRACKETS: "{">
	| <CLOSEDCURLYBRACKETS: "}">
	| <OPENSQUAREBRACKETS: "[">
	| <CLOSEDSQUAREBRACKETS: "]">
}

TOKEN[IGNORE_CASE]: /* CONSTRAINT SYNTAX*/
{ <NEQ: "!="> | <IN: "IN"> }

TOKEN: /* CREATED ENTITIES */
{	<GENERATEDENTITY: "!"<ENTITYNAMES>> }

TOKEN: /* MANSYNTAX KEYWORDS */
{	<SUBCLASSOF: "SubClassOf" | "subClassOf">
	|<EQUIVALENTTO: "EquivalentTo" | "equivalentTo">
	|<DISJOINTWITH: "DisjointWith" | "disjointWith">
	|<DISJOINT_UNION_OF: "DisjointUnionOf">
	|<FUNCTIONAL: "Functional">
	|<INVERSE: "inv">
	|<INVERSE_FUNCTIONAL: "InverseFunctional">
	|<SUB_PROPERTY_OF: "SubPropertyOf" | "subPropertyOf">
	|<SYMMETRIC: "Symmetric">
	|<TRANSITIVE: "Transitive">
}

TOKEN : /* VARIABLE SCOPE OTHER DIRECTIONS */
{	<OTHERDIRECTION: <SUPERCLASSOF> |<SUPER_PROPERTY_OF> |<INSTANCE_OF>>
	| <#SUPERCLASSOF: "SuperClassOf"|"superClassOf">
	|<#SUPER_PROPERTY_OF: "SuperPropertyOf"|"superPropertyOf">
	|<#INSTANCE_OF: "InstanceOf"|"instanceOf">
}



TOKEN :/* VARIABLE ATTRIBUTES*/
{	<RENDERINGVARIABLEATTRIBUTE: "RENDERING">|<VALUESVARIABLEATTRIBUTE: "VALUES">}

TOKEN : /* MANSYNTAX ENTITY NAMES */
{	<ENTITYNAMES : <LETTER> (<LETTER>|<DIGIT>)*>}

TOKEN: /* LITERALS*/
{	<LITERAL: <QUOTE><ENTITYNAMES><QUOTE><POWER><POWER><ENTITYNAMES>(<COLON> <ENTITYNAMES>)?>}

OPPLScript Start():{}
{
{return parse(null);}
}

OPPLScript parse(ConstraintSystem cs):{
	List<Variable> variables = new ArrayList<Variable>();
	OPPLQuery opplQuery = null;
	List<OWLAxiomChange> actions = new ArrayList<OWLAxiomChange>();
	ConstraintSystem constraintSystem = cs;
	if(constraintSystem==null){constraintSystem = getOPPLFactory().createConstraintSystem();}
}
{
  (variables = VariableDeclaration(constraintSystem))?(opplQuery = query(constraintSystem))?(actions = Actions(constraintSystem))?";"
  {
  	OPPLScript toReturn = getOPPLFactory().buildOPPLScript(constraintSystem, variables, opplQuery, actions);
  	if(validator !=null && !validator.accept(toReturn)){
  		throw new ParseException("Failed validation "+validator.getValidationRuleDescription());
  	}
  	return toReturn;
  }
}

List<Variable> VariableDeclaration(ConstraintSystem constraintSystem) #void :
{List<Variable> toReturn = new ArrayList<Variable>();
Variable v;}
{
	v =VariableDefinition(constraintSystem)
		{	toReturn.add(v);
			completions.clear();
			completions.add(",");
			completions.add("SELECT");
		}
	(	<COMMA>{completions.clear();}
		v = VariableDefinition(constraintSystem)
			{	toReturn.add(v);
				completions.clear();
				completions.add(",");
				completions.add("SELECT");
			}
	)*
	{return toReturn;}
}

List<OWLAxiomChange> Actions(ConstraintSystem constraintSystem):{List<OWLAxiomChange> toReturn = new ArrayList<OWLAxiomChange>(); OWLAxiomChange action;}
{
	<BEGIN> 	action = Action(constraintSystem){toReturn.add(action);}
	(	<COMMA> action = Action(constraintSystem){toReturn.add(action);}
	)*<END>
	{return toReturn;}
}

Variable VariableDefinition(ConstraintSystem constraintSystem):
	{	Token variableNameToken;
		Token variableTypeToken;
		VariableType variableType=null;
		VariableScope variableScope;
		Token directionToken=null;
		VariableScopes.Direction direction=null;
		Variable v=null;
	}
	{
	LOOKAHEAD(4)
	variableNameToken= <IDENTIFIER> <COLON>
		{	completions.clear();
			completions.addAll(EnumSet.allOf(VariableType.class));
		}
	variableTypeToken= <VARIABLETYPE>
		{variableType = VariableType.getVariableType(variableTypeToken.image);}
	"=" v = opplFunction(variableNameToken.image,variableType,constraintSystem)
	{return v;}
	|LOOKAHEAD(4)
	variableNameToken= <IDENTIFIER> <COLON>
		{	completions.clear();
			completions.addAll(EnumSet.allOf(VariableType.class));
		}
	variableTypeToken= <VARIABLETYPE>
		{
			try{
				variableType = VariableType.getVariableType(variableTypeToken.image);
    	        v =  constraintSystem.createVariable(variableNameToken.image,variableType);
			}catch(OPPLException e){throw new ParseException(e);}
		}
	<OPENSQUAREBRACKETS>
		{
			completions.clear();
			completions.addAll(EnumSet.allOf(VariableScopes.Direction.class));
		}
	direction = direction()
	variableScope = typeScope(direction, variableType,constraintSystem)
	<CLOSEDSQUAREBRACKETS>
		{
			v.setVariableScope(variableScope, getOPPLFactory().getVariableScopeChecker());
			return v;
		}
	|variableNameToken= <IDENTIFIER> <COLON>
		{
			completions.clear();
			completions.addAll(EnumSet.allOf(VariableType.class));
		}
	variableTypeToken = <VARIABLETYPE>
		{
			completions.clear();
			try{
				variableType = VariableType.getVariableType(variableTypeToken.image);
				return constraintSystem.createVariable(variableNameToken.image,variableType);
			}catch(OPPLException e){throw new ParseException(e);}
		}
}


GeneratedVariable opplFunction(String name,VariableType type, ConstraintSystem constraintSystem) #void:
{	GeneratedValue<String> value=null;
	AbstractCollectionGeneratedValue<? extends OWLObject> collection=null;
	GeneratedVariable expressionVariable;
	GeneratedVariable regexpVariable;
}
{
	/*<MATCH><OPENPARENTHESYS><QUOTE>regexpVariable = regexpOperation(name, type, constraintSystem)<QUOTE><CLOSEDPARENTHESYS>
		{return regexpVariable;}
	|*/
	<CREATE><OPENPARENTHESYS>value = stringOperation(constraintSystem)<CLOSEDPARENTHESYS>
		{return constraintSystem.createStringGeneratedVariable(name,type, value);}
	|<CREATEINTERSECTION><OPENPARENTHESYS>collection = set(type,constraintSystem)<CLOSEDPARENTHESYS>
		{return constraintSystem.createIntersectionGeneratedVariable(name,type,(AbstractCollectionGeneratedValue<OWLClass>) collection);}
	|<CREATEUNION><OPENPARENTHESYS> collection = set(type,constraintSystem)<CLOSEDPARENTHESYS>
		{return constraintSystem.createUnionGeneratedVariable(name,type,(AbstractCollectionGeneratedValue<OWLClass>) collection);}
	| expressionVariable = expressionGeneratedVariable(name,type,constraintSystem)
		{return expressionVariable;}
}

JAVACODE
GeneratedVariable expressionGeneratedVariable(String name,VariableType type, ConstraintSystem constraintSystem){
int beginningSubSection = token.beginColumn;
int beginningSubSectionLine = token.beginLine;
String expression = Utils.readString(true, COMMA, SELECT);
try {
	return Utils.parseVariableExpressionGeneratedVariable(name,	type, expression, constraintSystem);
} catch (ParserException e) {throw new ParseException(Utils.buildException(beginningSubSection, beginningSubSectionLine, e));}
}

JAVACODE
GeneratedVariable regexpOperation(String name,VariableType type, ConstraintSystem constraintSystem){
int beginningSubSection = token.beginColumn;
int beginningSubSectionLine = token.beginLine;
String expression = Utils.readString(false, QUOTE);
try {
	Pattern.compile(expression);
} catch (PatternSyntaxException e) {
	throw new ParseException(Utils.buildException(expression,beginningSubSection, beginningSubSectionLine, e));
}
try {
	return Utils.parseRegexpGeneratedVariable(name,	type, expression, constraintSystem);
} catch (ParserException e) {
	throw new ParseException(Utils.buildException(beginningSubSection, beginningSubSectionLine, e));
}
}

AbstractCollectionGeneratedValue<? extends OWLObject> set(VariableType type,ConstraintSystem constraintSystem) #void:
{Token variableNameToken=null;}
{
	variableNameToken = <IDENTIFIER>"."<VALUESVARIABLEATTRIBUTE>
		{	String variableName = variableNameToken.image;
			Variable v = constraintSystem.getVariable(variableName);
			if (v != null) {
				if (type == v.getType()) {
					Attribute attribute = Attribute.VALUES;
					return AttributeFactory.getCollectionGeneratedValue(attribute, v, constraintSystem);
				} else {throw new ParseException("Type mismatch for variable " + v.getName() + ": type " + type + " needed instead of the actual " + v.getType());}
			} else {throw new ParseException("Invalid variable name: " + variableName);}
		}
}

GeneratedValue<String> stringOperation(ConstraintSystem constraintSystem) #void:
{GeneratedValue result=null;}
{
	result = stringConcat(constraintSystem)
		{return result;}
}

GeneratedValue<String> stringConcat(ConstraintSystem constraintSystem) #void:
{	GeneratedValue aGeneratedValue;
	List<GeneratedValue<String>> components = new ArrayList<GeneratedValue<String>>();
}
{
	aGeneratedValue = generatedValue(constraintSystem)
		{components.add(aGeneratedValue);}
	("+"  aGeneratedValue = generatedValue(constraintSystem)
		{components.add(aGeneratedValue);}
	)*
		{if(components.size()==1){return aGeneratedValue;}else{return new ConcatGeneratedValues(components);}}
}

GeneratedValue generatedValue(ConstraintSystem constraintSystem) #void:
{	Token valueToken;
	Token variableNameToken;
	Token variableAttributeToken;
}
{
	<QUOTE>valueToken = <ENTITYNAMES><QUOTE>
		{return new StringGeneratedValue(valueToken.image);}
	|variableNameToken = <IDENTIFIER>"." variableAttributeToken = <RENDERINGVARIABLEATTRIBUTE>
		{	String attributeString = variableAttributeToken.image;
			String variableName = variableNameToken.image;
			Variable v = constraintSystem.getVariable(variableName);
			if(v !=null){
				if (attributeString == null) {throw new ParseException("Invalid attribute name: null; valid names are: "+ Arrays.toString(Attribute.values()));}
				try {
					Attribute attribute = Attribute.valueOf(attributeString);
					return AttributeFactory.getVariableGeneratedValue(attribute, v, constraintSystem);
				} catch (IllegalArgumentException e) {throw new ParseException("Invalid attribute name: " + e.getMessage() + "; valid names are: " + Arrays.toString(Attribute.values()));}
		}else{throw new ParseException("Invalid variable name: "+variableName);}
		}
}

VariableScopes.Direction direction() #void: {Token t=null;}
{
	<SUBCLASSOF>
		{return Direction.SUBCLASSOF;}
	| <SUB_PROPERTY_OF>
		{return Direction.SUBPROPERTYOF;}
	| t = <OTHERDIRECTION>
		{return Direction.getDirection(t.image);}
}


JAVACODE
VariableScope typeScope(VariableScopes.Direction direction, VariableType variableType, ConstraintSystem constraintSystem){
	int beginningSubSection = -1;
	int beginningSubSectionLine = -1;
	Token t;
	StringBuilder manSyntax = new StringBuilder();
	VariableScope toReturn = null;
	while (true) {
		t = getToken(1);
		if (beginningSubSection < 0) {
			beginningSubSection = t.beginColumn;
		}
		if (beginningSubSectionLine < 0) {
			beginningSubSectionLine = t.beginLine;
		}
		if (t.kind == COMMA || t.kind == CLOSEDSQUAREBRACKETS || t.kind == SEMICOLON || t.kind == BEGIN || t.kind == END || t.kind == WHERE || t.kind == EOF) {
			break;
		} else {
			manSyntax.append(t.image);
			manSyntax.append(" ");
			t = getNextToken();
		}
	}
	String manSyntaxString = manSyntax.toString().trim();
	completions.clear();
	// VariableManchesterOWLSyntaxParser parser = new
	// VariableManchesterOWLSyntaxParser(
	// manSyntaxString, constraintSystem);
	ManchesterOWLSyntaxEditorParser parser = new ManchesterOWLSyntaxEditorParser(getOWLOntologyManager().getOWLDataFactory(), manSyntaxString);
	parser.setOWLEntityChecker(getOPPLFactory().getOWLEntityChecker());
	try {
		toReturn = parseScope(direction, variableType, parser);
	} catch (ParserException e) {
		// No need to correct the column indexes on this exception, it
		// has been done near the generation point
		throw new ParseException("Failed to parse the description " + manSyntaxString, e);
	}
	return toReturn;
}

JAVACODE
VariableScope parseScope(VariableScopes.Direction direction,
			VariableType variableType, ManchesterOWLSyntaxEditorParser parser)
			throws ParserException {
		VariableScope scope = null;
		int beginningSubSection = token.beginColumn;
		int beginningSubSectionLine = token.beginLine;
		switch (variableType) {
			case CLASS:
				try {
					OWLDescription description = parser.parseDescription();
					if (direction.equals(Direction.SUBCLASSOF)) {
						scope = VariableScopes.buildSubClassVariableScope(description);
						} else {
							scope = VariableScopes.buildSuperClassVariableScope(description);
						}
					} catch (ParserException e) {
						throw Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
					}
					break;
				case OBJECTPROPERTY:
					try {
						OWLObjectProperty objectProperty = (OWLObjectProperty) parser.parseObjectPropertyExpression();
						if (direction.equals(Direction.SUPERPROPERTYOF)) {
							scope = VariableScopes.buildSuperPropertyVariableScope(objectProperty);
						} else {
							scope = VariableScopes.buildSubPropertyVariableScope(objectProperty);
						}
					} catch (ParserException e) {
						throw Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
					}
					break;
				case DATAPROPERTY:
					try {
						OWLDataProperty dataProperty = parser.parseDataProperty();
						if (direction.equals(Direction.SUPERPROPERTYOF)) {
							scope = VariableScopes.buildSuperPropertyVariableScope(dataProperty);
						} else {
							scope = VariableScopes.buildSubPropertyVariableScope(dataProperty);
						}
					} catch (ParserException e) {
						throw Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
					}
					break;
				case INDIVIDUAL:
					try {
						OWLDescription description = parser.parseDescription();
						scope = VariableScopes.buildIndividualVariableScope(description);
					} catch (ParserException e) {
						throw Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
					}
					break;
				default:
					break;
			}
			return scope;
	}


AbstractConstraint Constraint(ConstraintSystem constraintSystem):
{Token t;
OWLObject owlObject;
Variable variable;
Set<OWLObject> owlObjects = new HashSet<OWLObject>();
Set<OWLEntity> matches = new HashSet<OWLEntity>();}
{
	t = <IDENTIFIER>
		{
			variable = constraintSystem.getVariable(t.image);
			if(variable==null){throw new ParseException("Undeclared variable "+t.image);}
		}
	(	<MATCH><QUOTE> matches = matchConstraint(constraintSystem)<QUOTE>
		{return new InCollectionConstraint(variable, matches,constraintSystem);}
	|	<NEQ> owlObject = OWLExpression(variable, constraintSystem)
		{return new InequalityConstraint(variable, owlObject,constraintSystem);}
	|	<IN><OPENCURLYBRACKETS>owlObject = OWLExpression(variable,constraintSystem)
		{owlObjects.add(owlObject);}
	(<COMMA> owlObject = OWLExpression(variable,constraintSystem)
		{owlObjects.add(owlObject);}
	)*
	<CLOSEDCURLYBRACKETS>
		{return new InCollectionConstraint(variable,owlObjects, constraintSystem);}
	)
}

JAVACODE
Set<OWLEntity> matchConstraint(ConstraintSystem cs){
int beginningSubSection = getToken(1).beginColumn;
int beginningSubSectionLine = getToken(1).beginLine;
String expression = Utils.readString(false, QUOTE);
try {
	return RegExpGeneratedVariable.getMatches(expression, cs);
} catch (PatternSyntaxException e) {
	throw new ParseException(e.getMessage(), Utils.buildException(expression, beginningSubSection,beginningSubSectionLine, e));
}
}

JAVACODE
OWLObject OWLExpression(Variable v, ConstraintSystem constraintSystem)
{
		Token t;
		String manSyntaxString="";
		while(true){
			t = getToken(1);
			if (t.kind==COMMA || t.kind ==CLOSEDCURLYBRACKETS || t.kind==SEMICOLON || t.kind==BEGIN || t.kind==END || t.kind == WHERE || t.kind == EOF){
				break;
			}else{
				manSyntaxString += t.image+" ";
				t = getNextToken();
			}
		}
	VariableType type = v.getType();
	manSyntaxString = manSyntaxString.trim();
	ExpressionParser expressionParser = new ExpressionParser(manSyntaxString, constraintSystem,getOWLOntologyManager().getOWLDataFactory(), OPPLParser.getOWLOntologyManager());
	try{
	OWLObject toReturn = type.accept(expressionParser);
	return toReturn;
	} catch(Exception e){throw new ParseException(e);}
}

VariableType variableType() #void:{Token t;}
{
	t = <VARIABLETYPE>
		{return VariableType.getVariableType(t.image);}
}

OPPLQuery query(ConstraintSystem constraintSystem):{
	OPPLQuery toReturn = getOPPLFactory().buildNewQuery(constraintSystem);
	AbstractConstraint c;}
{
	<SELECT>
		{completions.clear();}
	queryAtom(toReturn,constraintSystem)
	(<COMMA>
		{completions.clear();}
	queryAtom(toReturn,constraintSystem))*
	(<WHERE> c=Constraint(constraintSystem)
		{toReturn.addConstraint(c);}
	 (<COMMA> c=Constraint(constraintSystem)
	 	{toReturn.addConstraint(c);}
	 )*)?
	{return toReturn;}
}

void queryAtom(OPPLQuery query, ConstraintSystem constraintSystem) #void: {OWLAxiom axiom;}
{
	<ASSERTED> axiom = Clause(constraintSystem)
		{query.addAssertedAxiom(axiom);}
	| axiom = Clause(constraintSystem)
		{query.addAxiom(axiom);}
}

OWLAxiomChange Action(ConstraintSystem constraintSystem):{OWLAxiom axiom;}
{
	<ADD> axiom = Clause(constraintSystem)
		{return new AddAxiom(constraintSystem.getOntology(), axiom);}
	|<REMOVE> axiom = Clause(constraintSystem)
		{return new RemoveAxiom(constraintSystem.getOntology(), axiom);}
}

JAVACODE
OWLAxiom Clause(ConstraintSystem constraintSystem){
	int beginningSubSection = -1;
	int beginningSubSectionLine = -1;
	OWLAxiom toReturn =null;
	String manSyntaxString="";
	Token t;
		while(true){
			t = getToken(1);
			if (beginningSubSection < 0) {beginningSubSection = t.beginColumn;}
			if (beginningSubSectionLine < 0) {beginningSubSectionLine = t.beginLine;}
			if (t.kind==COMMA || t.kind==SEMICOLON || t.kind==BEGIN || t.kind==END || t.kind == WHERE || t.kind == EOF){
				break;
			}else{
				manSyntaxString += t.image+" ";
				t = getNextToken();
			}
		}
	manSyntaxString = manSyntaxString.trim();
	VariableManchesterOWLSyntaxParser parser = new VariableManchesterOWLSyntaxParser(manSyntaxString, constraintSystem
					);
	//parser.setOWLEntityChecker(getOPPLFactory().getOWLEntityChecker());
	try{
		toReturn = parser.parseAxiom();

	}catch(ParserException e){
	throw new ParseException("OPPLParser.Clause() " + manSyntaxString, Utils.buildException(beginningSubSection, beginningSubSectionLine, e));
	}
return toReturn;
}

