/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. arithmetics.jj */
/*@egen*//**
* JJTree file
*/

options {
  JDK_VERSION = "1.5";
                 
               
                      
                                               
    DEBUG_TOKEN_MANAGER=false;
}
 
PARSER_BEGIN(ArithmeticsParser) 
package uk.ac.manchester.mae.parser;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.protege.editor.owl.model.OWLModelManager;
import org.semanticweb.owlapi.model.OWLDataProperty;
import org.semanticweb.owl.expression.OWLEntityChecker;
import org.semanticweb.owlapi.model.OWLObjectProperty;
import org.coode.manchesterowlsyntax.ManchesterOWLSyntaxEditorParser;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owl.expression.ParserException;
import org.semanticweb.owl.apibinding.OWLManager;
import org.semanticweb.owlapi.model.OWLObject;
import org.protege.editor.owl.ui.clsdescriptioneditor.AutoCompleterMatcher;

public class ArithmeticsParser/*@bgen(jjtree)*/implements ArithmeticsParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTArithmeticsParserState jjtree = new JJTArithmeticsParserState();

/*@egen*/
	
	static private OWLEntityChecker owlEntityChecker = null;
	
	static private AutoCompleterMatcher matcher;
	
	static private OWLDataFactory dataFactory = OWLManager.createOWLOntologyManager().getOWLDataFactory();
	
	static public void setOWLDataFactory(OWLDataFactory dataFactory){
		ArithmeticsParser.dataFactory = dataFactory;
	}
	
	static{
		initCompletions();
	}
	static public void setOWLEntityChecker(OWLEntityChecker owlEntityChecker){
		ArithmeticsParser.owlEntityChecker = owlEntityChecker;
	}
	
	static public void setAutoCompleterMatcher(AutoCompleterMatcher matcher){
		ArithmeticsParser.matcher = matcher;
	}
	
	// Unchecked on purpose as it must contain both OWLObject instances and String
	@SuppressWarnings("unchecked")
	private static List completions;
	
	@SuppressWarnings("unchecked")
	public static List getCompletions(){
		return completions;
	}	
	
	@SuppressWarnings("unchecked")
	private static void initCompletions(){
		if(completions ==null){
        			completions = new ArrayList();
        }
		completions.clear();
		completions.add("$");
		completions.add("APPLIESTO <");
		completions.add("STORETO <");
		completions.add("{");
	}
	
	private static void initCompletions(boolean conflictExpressed,
								 boolean appliesToExpressed, 
								 boolean storeToExpressed,
								 boolean bindingExpressed){
		initCompletions();
		if(conflictExpressed){
				completions.remove("$");
		}
		if(appliesToExpressed){
			completions.remove("$");
			completions.remove("APPLIESTO <");
		}
		if(storeToExpressed){
			completions.remove("$");
			completions.remove("APPLIESTO <");
			completions.remove("STORETO <");
		}
		if(bindingExpressed){
			completions.remove("$");
			completions.remove("APPLIESTO <");
			completions.remove("STORETO <");
			completions.remove("{");
		}
		
	}
	
  public static void main(String args[]) {
    System.out.println("Reading from standard input...");
    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");
    new ArithmeticsParser(System.in);
    try {
      SimpleNode n = ArithmeticsParser.Start();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }
}
PARSER_END(ArithmeticsParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN: /*DELIMITERS*/
{
	<BINDINGEND: "}->">
	|<OPENCURLYBRACKET: "{">
	| <CLOSEDCURLYBRACKET: "}">
	| <EXCLAMATION: " o ">
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}

TOKEN: /*Strategies*/
{
	<STRATEGY: "OVERRIDING" | "OVERRIDDEN" | "EXCEPTION">
}

TOKEN:{
	<NUMBER : <INTEGER_LITERAL> (<URISYMBOLS> <INTEGER_LITERAL>)?>
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
 
 | <URISYMBOLS: ":" | "." | "#" | "~" | "[" | "]">

  
}

TOKEN : /* OPERATORS */
{
	
	<SUM: ("+"|"-")>
	|<MULTIPLY: ( "*" | "/" | "%" )>
}




SimpleNode Start() : {/*@bgen(jjtree) Start */
                      MAEStart jjtn000 = new MAEStart(JJTSTART);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Set<String> variables = new HashSet<String>();
								 boolean conflictExpressed = false;
								 boolean appliesToExpressed = false; 
								 boolean storeToExpressed = false;
								 boolean bindingExpressed = false;}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/

  (ConflictStrategy()
  {
  	conflictExpressed = true;
  }
  )?
  {
	initCompletions(conflictExpressed, appliesToExpressed, storeToExpressed, bindingExpressed);
  }
  (AppliesTo()
  {
  	appliesToExpressed = true;
  }
  )?
  {
	initCompletions(conflictExpressed, appliesToExpressed, storeToExpressed, bindingExpressed);
  }
  (StoreTo()
  	{
  	 storeToExpressed = true;
  	}
  )?
  {
	initCompletions(conflictExpressed, appliesToExpressed, storeToExpressed, bindingExpressed);
  }
  ("{"
  {
  	initCompletions(conflictExpressed, appliesToExpressed, storeToExpressed, bindingExpressed);
  }
  Binding(variables) 
  {
  	bindingExpressed = true;
  	completions.addAll(variables);
  }   
  ("," Binding(variables)
  	{
  		completions.addAll(variables);
  	}
  )* "}->")?
   
  (Expression(variables) | Function(variables)) ";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 	
  	return jjtn000; 
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void ConflictStrategy():{/*@bgen(jjtree) ConflictStrategy */
                         MAEConflictStrategy jjtn000 = new MAEConflictStrategy(JJTCONFLICTSTRATEGY);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ConflictStrategy */
         try {
/*@egen*/
	 "$" {
	  		completions.clear();
            completions.add("$OVERRIDING$");
            completions.add("$OVERRIDDEN$");
            completions.add("$EXCEPTION$");
	 }
	 t = <STRATEGY>{
	 	jjtn000.setStrategyName(t.image);
	 }
	"$"/*@bgen(jjtree)*/
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void StoreTo():{/*@bgen(jjtree) StoreTo */
  MAEStoreTo jjtn000 = new MAEStoreTo(JJTSTORETO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StoreTo */
        try {
/*@egen*/
	"STORETO <"
	{ 
		completions.clear();
	}
	 propertyChainExpression() ">"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AppliesTo()       :{}
{
	"APPLIESTO <"
	{ 
		completions.clear();
	}
		 manSyntaxClassExpression() ">"
}


JAVACODE

	void manSyntaxClassExpression(){/*@bgen(jjtree) manSyntaxClassExpression */
             MAEmanSyntaxClassExpression jjtn000 = new MAEmanSyntaxClassExpression(JJTMANSYNTAXCLASSEXPRESSION);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
             try {
/*@egen*/
		Token t;
		while(true){
			t = getToken(1);
			if (t.image.equals(">") || t.image.equals("]") || t.kind == EOF){
				break;
			}else{
				jjtn000.setContent(jjtn000.getContent()+(jjtn000.getContent().equals("")?"":" ")+t.image);
				t = getNextToken();
			}
		}
		String content = jjtn000.getContent();
		ManchesterOWLSyntaxEditorParser parser = new ManchesterOWLSyntaxEditorParser(dataFactory,content);
        parser.setOWLEntityChecker(owlEntityChecker);
        try {
        	parser.parseDescription();
        }catch(ParserException e){
        	if(matcher!=null){
				int lastIndexOfWhiteSpace = content.lastIndexOf(" ");
				String word = lastIndexOfWhiteSpace == -1 ? content
						: content.substring(lastIndexOfWhiteSpace).trim();
				Set<OWLObject> matches = matcher
						.getMatches(word, e.isClassNameExpected(), e
								.isObjectPropertyNameExpected(), e
								.isDataPropertyNameExpected(), e
								.isIndividualNameExpected(), e
								.isDatatypeNameExpected());
				List kwMatches = new ArrayList(matches.size() + 10);
				for (String s : e.getExpectedKeywords()) {
					if (word.matches("(\\s)*") || s.toLowerCase().startsWith(word.toLowerCase())) {
						kwMatches.add(s);
					}
				}
				completions.addAll(kwMatches);
				completions.addAll(matches);
				}
        	throw new ParseException(e.getMessage());
        }
        String expression = content+"**";	
        ManchesterOWLSyntaxEditorParser completerParser = new ManchesterOWLSyntaxEditorParser(dataFactory,expression);
        completerParser.setOWLEntityChecker(owlEntityChecker);
        try{
        	completerParser.parseDescription();
		} catch (ParserException e) {
				if(matcher!=null){
				int lastIndexOfWhiteSpace = expression.lastIndexOf(" ");
				String word = lastIndexOfWhiteSpace == -1 ? ""
						: content.substring(lastIndexOfWhiteSpace).trim();
				List<String> kwMatches = new ArrayList<String>(10);
				for (String s : e.getExpectedKeywords()) {
					if (word.matches("(\\s)*") || s.toLowerCase().startsWith(word.toLowerCase())) {
						kwMatches.add(s);
					}
				}
				completions.addAll(kwMatches);
				}
		}/*@bgen(jjtree)*/
             } finally {
               if (jjtc000) {
                 jjtree.closeNodeScope(jjtn000, true);
               }
             }
/*@egen*/
	}
	
	
JAVACODE

void propertyChainExpression() throws ParseException {/*@bgen(jjtree) propertyChainExpression */
             MAEpropertyChainExpression jjtn000 = new MAEpropertyChainExpression(JJTPROPERTYCHAINEXPRESSION);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
             try {
/*@egen*/
		/* @bgen(jjtree) propertyChainExpression */
		MAEpropertyChainExpression jjtn000 = new MAEpropertyChainExpression(
				JJTPROPERTYCHAINEXPRESSION);
		boolean jjtc000 = true;
		jjtree.openNodeScope(jjtn000);
		try {
			Token t;
			while (true) {
				t = getToken(1);
				if (t.image.equals("}") || t.image.equals(",")
						|| t.image.equals(">") || t.image.equals("}->")) {
					break;
				} else {
					jjtn000.setContent(jjtn000.getContent() + t.image);
					t = getNextToken();
				}
			}
			// should contain the property chain up to the next comma or close
			// brace
			String content = jjtn000.getContent();
			jjtn000.setCells(parsePropertyChain(content));
			/* @bgen(jjtree) */
		} finally {
			if (jjtc000) {
				jjtree.closeNodeScope(jjtn000, true);
			}
		}/*@bgen(jjtree)*/
             } catch (Throwable jjte000) {
               if (jjtc000) {
                 jjtree.clearNodeScope(jjtn000);
                 jjtc000 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte000 instanceof ParseException) {
                 throw (ParseException)jjte000;
               }
               throw (Error)jjte000;
             } finally {
               if (jjtc000) {
                 jjtree.closeNodeScope(jjtn000, true);
               }
             }
/*@egen*/
	}
	
JAVACODE

List<MAEpropertyChainCell> parsePropertyChain(String _text)
			throws ParseException {/*@bgen(jjtree) parsePropertyChain */
             MAEparsePropertyChain jjtn000 = new MAEparsePropertyChain(JJTPARSEPROPERTYCHAIN);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
             try {
/*@egen*/
		List<MAEpropertyChainCell> toReturn = new ArrayList<MAEpropertyChainCell>();
		String[] values = split(_text.trim(), " o ", " o");
		for (int i = 0; i < values.length; i++) {
			boolean opensquare = values[i].contains("[");
			boolean closesquare = values[i].contains("]");
			if (opensquare != closesquare) {
				// then there is either an open square or a
				// closed square bracket but not both: exception
				throw new ParseException("Unbalanced brackets: " + values[i]);
			}
			String propertyName = values[i];
			// if there are brackets:
			if (values[i].indexOf("[") > -1) {
				propertyName = propertyName
						.substring(0, values[i].indexOf("["));
			}
			if (propertyName.length() == 0) {
				// there is no property name: error
				throw new ParseException("property name missing: " + values[i]);
			}
			String facet = null;
			if (opensquare && closesquare) {
				int open = values[i].indexOf('[');
				facet = values[i].substring(open + 1, values[i].indexOf(']'))
						.trim();
			}
			// no exceptions: means there is a name and a facet, or the
			// facet is null{
			MAEpropertyChainCell cell = new MAEpropertyChainCell(propertyName,
					facet);
			cell.setContent(values[i]);
			toReturn.add(cell);
		}
		return toReturn;/*@bgen(jjtree)*/
             } catch (Throwable jjte000) {
               if (jjtc000) {
                 jjtree.clearNodeScope(jjtn000);
                 jjtc000 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte000 instanceof ParseException) {
                 throw (ParseException)jjte000;
               }
               throw (Error)jjte000;
             } finally {
               if (jjtc000) {
                 jjtree.closeNodeScope(jjtn000, true);
               }
             }
/*@egen*/
	}

JAVACODE

String[] split(String text, String string,
			String alternateForm) {/*@bgen(jjtree) split */
             MAEsplit jjtn000 = new MAEsplit(JJTSPLIT);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
             try {
/*@egen*/
		// alternateForm is only valid at the end of the string
		List<String> toReturn = new ArrayList<String>();
		int index = text.indexOf(string);
		while (index > -1) {
			toReturn.add(text.substring(0, index).trim());
			text = text.substring(index + string.length());
			index = text.indexOf(string);
		}
		// an incomplete delimiter will have left: last field + incomplete
		// delimiter
		// once there are no more "string", check for the alternate form
		if (text.endsWith(alternateForm)) {
			toReturn.add(text.replace(alternateForm, "").trim());
			// empty field at the end of the chain
			toReturn.add("");
		} else {
			toReturn.add(text.trim());
		}
		return toReturn.toArray(new String[toReturn.size()]);/*@bgen(jjtree)*/
             } finally {
               if (jjtc000) {
                 jjtree.closeNodeScope(jjtn000, true);
               }
             }
/*@egen*/
	}


void Binding(Set<String> variables):{/*@bgen(jjtree) Binding */
                                     MAEBinding jjtn000 = new MAEBinding(JJTBINDING);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token identifier; Token propertyName;}
{/*@bgen(jjtree) Binding */
        try {
/*@egen*/
	identifier=<IDENTIFIER>
	{
		variables.add(identifier.image);
		jjtn000.setIdentifier(identifier.image);
	}
	"=" propertyChainExpression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression(Set<String> variables)       : {}
{

  AdditiveExpression(variables) 
  
}

void AdditiveExpression(Set<String> variables)       : {Token op =null;}
{/*@bgen(jjtree) #Add(> 1) */
  {
    MAEAdd jjtn001 = new MAEAdd(JJTADD);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
	
  (
  	 MultiplicativeExpression(variables) (  op=<SUM> {
    	jjtn001.setSum(op == null || op.image.compareTo("+")==0);
    	
    } AdditiveExpression(variables) )*
    
    
    
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/         
}

void MultiplicativeExpression(Set<String> variables)       : {Token op =null;}
{/*@bgen(jjtree) #Mult(> 1) */
  {
    MAEMult jjtn001 = new MAEMult(JJTMULT);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    UnaryExpression(variables) ( op =<MULTIPLY> { 
     jjtn001.setMultiplication(op == null || op.image.compareTo("*")==0);
     jjtn001.setPercentage(op != null && op.image.compareTo("%")==0);
    }
    MultiplicativeExpression(variables) )*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/          
}

void UnaryExpression(Set<String> variables)       : {}
{
	LOOKAHEAD(2)
	Power(variables)	
  |"(" Expression(variables) ")"  
  |  groundTerm(variables)
}

void Power(Set<String> variables) :{/*@bgen(jjtree) Power */
                                    MAEPower jjtn000 = new MAEPower(JJTPOWER);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/Double base=null; Double exp; Token baseId=null;}
{/*@bgen(jjtree) Power */
        try {
/*@egen*/
	(
		((base = Integer()) | baseId =<IDENTIFIER>{
			if(!variables.contains(baseId.image)){
				throw new ParseException("Unbound symbol: "+baseId.image);
			}
		}
		) "^" exp = Integer()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			if(base!=null){
				jjtn000.setBase(base);
			}else{
				jjtn000.setSymbolic(true);
				jjtn000.setBaseIdentifier(baseId.image);
			}
			jjtn000.setExp(exp);
		}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


double Integer()          :{/*@bgen(jjtree) IntNode */
                            MAEIntNode jjtn000 = new MAEIntNode(JJTINTNODE);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} 
{/*@bgen(jjtree) IntNode */
try {
/*@egen*/
	
t = <NUMBER>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/ 
{
  	jjtn000.setValue(Double.parseDouble(t.image));
  	jjtn000.setSymbolic(false);
  	return jjtn000.getValue();
  	}
| t= <INTEGER_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	jjtn000.setValue(Double.parseDouble(t.image));
  	jjtn000.setSymbolic(false);
  	return jjtn000.getValue();
  	}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}




void Identifier(Set<String> variables)            : {/*@bgen(jjtree) Identifier */
                                                     MAEIdentifier jjtn000 = new MAEIdentifier(JJTIDENTIFIER);
                                                     boolean jjtc000 = true;
                                                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
	t=<IDENTIFIER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{
		if(!variables.contains(t.image)){
			throw new ParseException("Unbound symbol: "+t.image);
		}
		jjtn000.setIdentifierName(t.image);
		jjtn000.setSymbolic(true);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void groundTerm(Set<String> variables)      : {}
{
	(Integer() |  Identifier(variables) ) 
}

void Function(Set<String> variables)      :{}
{  
	
	BigSum(variables)
}

void BigSum(Set<String> variables) :{/*@bgen(jjtree) BigSum */
  MAEBigSum jjtn000 = new MAEBigSum(JJTBIGSUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BigSum */
        try {
/*@egen*/
	
	("SUM("|"sum(")  Expression(variables)")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}