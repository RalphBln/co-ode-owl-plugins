/**
* JJTree file
*/

options {
  JDK_VERSION = "1.5";
  MULTI = true;
  NODE_PREFIX = "Pattern";

  STATIC = false;
}

PARSER_BEGIN(PatternParser)
package org.coode.patterns.syntax;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.coode.oppl.OPPLScript;
import org.coode.oppl.variablemansyntax.ConstraintSystem;
import org.coode.oppl.variablemansyntax.ExpressionParser;
import org.coode.oppl.variablemansyntax.Variable;
import org.coode.oppl.variablemansyntax.VariableManchesterOWLSyntaxParser;
import org.coode.oppl.variablemansyntax.VariableType;
import org.coode.oppl.variablemansyntax.generated.AbstractCollectionGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.Attribute;
import org.coode.oppl.variablemansyntax.generated.ConcatGeneratedValues;
import org.coode.oppl.variablemansyntax.generated.SingleValueGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.SingleValueGeneratedVariable;
import org.coode.oppl.variablemansyntax.generated.RegExpGenerated;
import org.coode.oppl.variablemansyntax.generated.StringGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.VariableIndexGeneratedValue;
import org.coode.oppl.variablemansyntax.generated.factory.AttributeFactory;
import org.coode.patterns.AbstractPatternModelFactory;
import org.coode.patterns.InstantiatedPatternModel;
import org.coode.patterns.PatternConstant;
import org.coode.patterns.PatternConstraintSystem;
import org.coode.patterns.PatternException;
import org.coode.patterns.PatternModel;
import org.coode.patterns.PatternOPPLScript;
import org.coode.patterns.PatternSignature;
import org.coode.patterns.utils.ParserFactory;
import org.coode.patterns.utils.Utils;
import org.protege.editor.owl.model.OWLModelManager;
import org.semanticweb.owl.apibinding.OWLManager;
import org.semanticweb.owl.expression.ParserException;
import org.semanticweb.owl.inference.OWLReasoner;
import org.semanticweb.owl.model.OWLAxiom;
import org.semanticweb.owl.model.OWLClass;
import org.semanticweb.owl.model.OWLDataFactory;
import org.semanticweb.owl.model.OWLEntity;
import org.semanticweb.owl.model.OWLObject;
import org.semanticweb.owl.model.OWLOntology;
import org.semanticweb.owl.model.OWLOntologyManager;

public class PatternParser {
	private OWLOntologyManager owlOntologyManager;
	//private static PatternConstraintSystem constraintSystem;
	private OWLReasoner reasoner;
	private AbstractPatternModelFactory modelFactory;
	private String unresolvedString ="";
	private List<PatternOPPLScript> dependencies = new ArrayList<PatternOPPLScript>();
	private Set<String> visited= new HashSet<String>();
	//Unchecked on purpose as it must contain both OWLObject instances and String
	private List completions = new ArrayList();

	public List getCompletions(){
		return this.completions;
	}


	public void addVisited(String patternName){
		visited.add(patternName);
	}

	public void setPatternModelFactory(AbstractPatternModelFactory mf){
		modelFactory = mf;
	}

	public AbstractPatternModelFactory getPatternModelFactory(){
		return modelFactory;
	}

	public OWLReasoner getReasoner(){
		return reasoner;
	}

	public OWLDataFactory getOWLDataFactory(){
		return owlOntologyManager.getOWLDataFactory();
	}

	public OWLOntologyManager getOWLOntologyManager(){
		return owlOntologyManager;
	}

	public PatternParser(java.io.InputStream in, OWLOntologyManager m, OWLReasoner r){
		this(in);
		owlOntologyManager = m;
		reasoner = r;
	}

   	public void ReInit(Reader reader, OWLOntologyManager m,  OWLReasoner r) {
		ReInit(reader);
		owlOntologyManager  = m;
		reasoner = r;
	}

   	public PatternParser(Reader reader, OWLOntologyManager m) {
		this(reader);
		owlOntologyManager = m;
	}

	public PatternParser(Reader reader, OWLOntologyManager m, OWLReasoner r) {
		this(reader,m);
		reasoner = r;
	}

	public void initOPPLParser(String s, OWLOntology o){
		modelFactory.setOPPLParser(org.coode.oppl.utils.ParserFactory.initParser(s, o, owlOntologyManager, null));
	}

	public void initProtegeOPPLParser(String s, OWLModelManager modelManager){
		modelFactory.setOPPLParser(org.coode.oppl.utils.ProtegeParserFactory.initParser(s, modelManager, null));
	}


	public void setVisited(Set<String> visitedPatternNames) {
		this.visited = visitedPatternNames;
	}

  public static void main(String args[]) {
  	String ontologyURIString = args[0];
  	OWLOntologyManager ontologyManager = OWLManager.createOWLOntologyManager();
  	try {
		OWLOntology ontology = ontologyManager.loadOntology(URI.create(ontologyURIString));
    	System.out.println("Reading from  standard input...");
    	System.out.print("Enter an expression: ");
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		String line = reader.readLine();
		PatternParser parser = ParserFactory.initParser(line, ontology, ontologyManager);
		parser.Start();
		System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      e.printStackTrace();
      System.out.println(e.getMessage());
    }
  }
}
PARSER_END(PatternParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}

TOKEN : /*ACTION SYNTAX*/
{
	<END: "END"<SEMICOLON>>
	|<ACTIONTOKENS: "BEGIN" | "ADD" | "REMOVE">
}

TOKEN[IGNORE_CASE]:/* OPPL FUNCTIONS*/
{
	/*<CREATE:   "create">
	| <CREATEINTERSECTION: "CreateIntersection">
	| <CREATEUNION: "CreateUnion">
	| <MATCH:"Match">*/
<OPPLFUNCTION: "create" |"CreateIntersection"|"CreateUnion"|"Match">
}

/* MANSYNTAX KEYWORDS */
/*TOKEN:
{	<SUBCLASSOF: "SubClassOf" | "subClassOf">
	|<EQUIVALENTTO: "EquivalentTo" | "equivalentTo">
	|<DISJOINTWITH: "DisjointWith" | "disjointWith">
	|<DISJOINT_UNION_OF: "DisjointUnionOf">
	|<FUNCTIONAL: "Functional">
	|<INVERSE: "inv">
	|<INVERSE_FUNCTIONAL: "InverseFunctional">
	|<SUB_PROPERTY_OF: "SubPropertyOf" | "subPropertyOf">
	|<SYMMETRIC: "Symmetric">
	|<TRANSITIVE: "Transitive">
}*/

TOKEN : /* VARIABLE SCOPE OTHER DIRECTIONS */
{	<OTHERDIRECTION: <SUPERCLASSOF> |<SUPER_PROPERTY_OF> |<INSTANCE_OF>>
	| <#SUPERCLASSOF: "SuperClassOf"|"superClassOf">
	|<#SUPER_PROPERTY_OF: "SuperPropertyOf"|"superPropertyOf">
	|<#INSTANCE_OF: "InstanceOf"|"instanceOf">
}

TOKEN : /*VARIABLE NAMES*/
{
	<VARIABLENAME: "?"<IDENTIFIER>>
	|<VARIABLETYPE: "CLASS" | "OBJECTPROPERTY" | "DATAPROPERTY" | "INDIVIDUAL" | "CONSTANT">
	|<PATTERNREFERENCEVARIABLE: <VARIABLENAME><OPENPARENTHESYS>(<IDENTIFIER>(<COMMA><IDENTIFIER>))*<CLOSEDPARENTHESYS>>
}
TOKEN :/* VARIABLE ATTRIBUTES*/
{	<RENDERINGVARIABLEATTRIBUTE: "RENDERING">|<VALUESVARIABLEATTRIBUTE: "VALUES">|<GROUPSVARIABLEATTRIBUTE: "GROUPS">}

TOKEN : /*RETURN*/
{
	<RETURN: "RETURN" | "return">
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| <CREATEDIDENTIFIER: "!"<IDENTIFIER>>
|  < #LETTER: ["_","\'","-","a"-"z","A"-"Z"] >
|  < #DIGIT: ["0"-"9"] >
}

/*TOKEN:
{<REGEXPMETACHAR:["\\","-","$","|","?","*"]>}
*/

TOKEN: /*PUNCTUATION*/
{
	<COMMA:",">
	| <SEMICOLON: ";">
	| <COLON: ":">
	| <OPENPARENTHESYS: "(">
	| <CLOSEDPARENTHESYS: ")">
	| <QUOTE: "\"">
	| <POWER: "^">
	| <DOT: ".">
	| <PLUS: "+">
	| <OPENCURLYBRACKETS: "{">
	| <CLOSEDCURLYBRACKETS: "}">
	| <OPENSQUAREBRACKETS: "[">
	| <CLOSEDSQUAREBRACKETS: "]">
	| <EQUALS:"=">
}

/*TOKEN:{
<ALLOWEDBETWEENQUOTES:<IDENTIFIER>|<OPENPARENTHESYS>|<CLOSEDPARENTHESYS>
|<OPENSQUAREBRACKETS>|<CLOSEDSQUAREBRACKETS>|<POWER>|<DOT>
|<REGEXPMETACHAR>|<PLUS>|<COMMA>>
}*/

TOKEN : /* PATTERN CONSTANTS*/
{
	<THISCLASS: "$thisClass">
	|<DOLLAR: "$">
	/*|<PATTERNREFERENCE: "$"<IDENTIFIER>> */
}

TOKEN:
{
	<CREATESYMBOL: "!">
}

PatternOPPLScript Start():{
OPPLScript opplStatement;
String rendering=null;
InstantiatedPatternModel instantiatedPatternModel=null;
Variable returnVariable=null;}
{
	instantiatedPatternModel = patternInstantiation()
		{
		for (PatternOPPLScript dependency : this.dependencies) {
			instantiatedPatternModel.addDependency(dependency);
		}
		instantiatedPatternModel.setUnresolvedOPPLStatement(unresolvedString);
  		return instantiatedPatternModel;
  		}
| 	opplStatement = OPPLPatternStatement(modelFactory.createConstraintSystem())
	rendering = Rendering(opplStatement.getConstraintSystem())
	(<SEMICOLON> returnVariable = returnClause((PatternConstraintSystem)opplStatement.getConstraintSystem()))?
		{
		PatternModel toReturn = modelFactory.createPatternModel(opplStatement);
		toReturn.setUnresolvedOPPLStatement(unresolvedString);
		toReturn.setRendering(rendering);
		for (PatternOPPLScript dependency : this.dependencies) {
           	toReturn.addDependency(dependency);
        }
		toReturn.setReturnVariable(returnVariable);
  		return toReturn;
  		}
}


Variable returnClause(PatternConstraintSystem constraintSystem) #void:{Token t=null;}
{
	LOOKAHEAD(2)
	<RETURN> t = <VARIABLENAME>
		{
		Variable v = constraintSystem.getVariable(t.image);
		if(v!=null){return v;}else{throw new ParseException("Undefined Variable "+ t.image);}
		}
	|<RETURN> t = <THISCLASS>{return constraintSystem.getThisClassVariable();}
}

InstantiatedPatternModel patternInstantiation() #void:{Token t;List<List<String>> args;PatternSignature signature = null;}
{
	<DOLLAR>{
		this.completions.clear();
		Set<String> possibleNames = Utils.getExistingPatternNames(getOWLOntologyManager());
		for(String name: possibleNames){
			this.completions.add("$"+name);
		}
	} t = <IDENTIFIER>{
		this.completions.clear();
		possibleNames = Utils.getExistingPatternNames(getOWLOntologyManager(),t.image);
		for(String name: possibleNames){
			this.completions.add("$"+name);
		}
	}
	<OPENPARENTHESYS>{
		try{
			signature = new PatternSignature(t.image, getOWLOntologyManager(), this.modelFactory);
		}catch (PatternException e) {
			throw new ParseException(e.getMessage(), e);
		}
	}
	args=argList(signature)<CLOSEDPARENTHESYS>
		{
		try {
			this.completions.clear();
			InstantiatedPatternModel resolvedPattern =
				signature.getPattern().getConstraintSystem().resolvePatternInstantiation(
					t.image,
					owlOntologyManager,
					this.visited,
					this.dependencies,
					args.toArray(new List[args.size()]));
			unresolvedString = "$"+t.image+"(";
			boolean first = true;
			for(List<String> anArgument: args){
				if(!first){unresolvedString+=", ";}else{first = false;}
				if(anArgument.size()==1){
					unresolvedString+=anArgument.iterator().next();
				}else{
					boolean firstSubArg= true;
					unresolvedString+="{";
					for(String subArg: anArgument){
						unresolvedString+=firstSubArg?subArg:", "+subArg;
						firstSubArg=firstSubArg?false:firstSubArg;
					}
					unresolvedString+="}";
				}
			}
			unresolvedString+=")";
			return resolvedPattern;
		} catch (PatternException e) {throw new ParseException(e.getMessage(), e);}
	}
}

JAVACODE
OPPLScript OPPLPatternStatement(PatternConstraintSystem constraintSystem){
	StringBuilder stringbuilder = new StringBuilder();
	this.unresolvedString = "";
	Token t;
	while (true) {
		t = this.getToken(1);
		if (t.kind == EOF) {break;}
		else {
			stringbuilder.append(this.resolvedString(constraintSystem, true));
			stringbuilder.append(" ");
			if (t.kind == END) {break;}
		}
	}
	String string = stringbuilder.toString().replace("BEGIN", "\nBEGIN\n").replace("END;", "\nEND;");
	try {
		this.modelFactory.initOPPLParser(string, constraintSystem.getReasoner());
		return this.modelFactory.getOPPLParser().parse(constraintSystem);
	} catch (Exception e) {
		throw new ParseException("The compiled OPPL script cannot be parsed correctly:\n" + "Compiled pattern: \n" + string + "\nerror message: \"" + e.getMessage() + "\"", e);
	}
}

JAVACODE
String Rendering(ConstraintSystem constraintSystem)
{
	String string="";
	Token t;
	while(true){
		t = getToken(1);
		if (t.kind == EOF || t.kind==SEMICOLON){
			break;
		}else if(t.kind == VARIABLENAME){
			Variable v = constraintSystem.getVariable(t.image);
			if(v==null){
				throw new ParseException("Undefined Variable "+t.image);
			}else{
				string+=t.image+" ";
				t = getNextToken();
			}
		}else{
			string += t.image+" ";
			t = getNextToken();
		}
	}
	return string;
}


String resolvedString(PatternConstraintSystem constraintSystem, boolean writeUnresolved) #void :{
	Token t=null;String resolvedPattern=null;
	String variableDefinition=null;
	String partial;}
{
	variableDefinition=variableReference(constraintSystem){if(writeUnresolved){unresolvedString+=variableDefinition+" ";}return variableDefinition;}
	| resolvedPattern =resolveInnerPattern(constraintSystem){return resolvedPattern;}
	| t = <THISCLASS>{
		if(writeUnresolved){unresolvedString += t.image+" ";}
		 return new PatternConstant<OWLClass>(PatternConstraintSystem.THIS_CLASS_VARIABLE_NAME,
		 VariableType.CLASS, constraintSystem.getOntologyManager().getOWLDataFactory()).getName();
	}
	| t = <ACTIONTOKENS>{if(writeUnresolved){unresolvedString += t.image+" ";}return t.image;}
	| t = <END>{if(writeUnresolved){unresolvedString += t.image+" ";}return t.image;}
	| t = <IDENTIFIER>{if(writeUnresolved){unresolvedString += t.image+" ";}return t.image;}
	| t= <CREATEDIDENTIFIER>{unresolvedString+= t.image+" ";return t.image;}
	| t=<OPENCURLYBRACKETS>{if(writeUnresolved){unresolvedString += t.image;}return t.image;}
	| t=<CLOSEDCURLYBRACKETS>{if(writeUnresolved){unresolvedString += t.image+" ";}return t.image;}
	| t=<COMMA>{if(writeUnresolved){unresolvedString += t.image+" ";}return t.image;}
	| t=<OPENPARENTHESYS>{if(writeUnresolved){unresolvedString += t.image;}return t.image;}
	| t=<CLOSEDPARENTHESYS>{if(writeUnresolved){unresolvedString += t.image+" ";}return t.image;}
	| t=<INTEGER_LITERAL>{if(writeUnresolved){unresolvedString += t.image+" ";}return t.image;}
	| t=<SEMICOLON>{if(writeUnresolved){unresolvedString += t.image;}return "";}
	| <QUOTE> partial=simpleCall()<QUOTE>{if(writeUnresolved){unresolvedString += "\""+partial+"\"";}return "\""+partial+"\"";}
	| t = <DOT>{if(writeUnresolved){unresolvedString += t.image+" ";}return  t.image;}
	| t = <PLUS>{if(writeUnresolved){unresolvedString += t.image+" ";}return  t.image;}

}

JAVACODE
String simpleCall(){
return PatternUtils.readString(this, true, QUOTE);
}

String variableReference(PatternConstraintSystem constraintSystem) #void:{
	Token variableNameToken;
	Token variableType;
	Token directionToken = null;
	Token scopeToken=null;
	String scopeString="";
	Token opplFunctionName=null;
	String opplFunctionArgs="";
	String variableExpression="";
	String opplFunction="";
	//SingleValueGeneratedVariable opplFunctionVariable;
	Token groupnumber;
	}
{
	LOOKAHEAD(4)
	variableNameToken =<VARIABLENAME><COLON> variableType =<VARIABLETYPE>  <OPENSQUAREBRACKETS> directionToken = <IDENTIFIER> (scopeToken = <IDENTIFIER>)+ {
		scopeString+=" "+scopeToken.image;
	}<CLOSEDSQUAREBRACKETS>{
		return variableNameToken.image+":"+variableType.image+"["+directionToken.image+" "+scopeString.trim()+"]";
	}
	|
	LOOKAHEAD(4)
	variableNameToken= <VARIABLENAME> <COLON> variableType= <VARIABLETYPE><EQUALS> opplFunction = opplFunction(variableNameToken.image, variableType.image, constraintSystem)
	{

		return variableNameToken.image+":"+variableType.image+" = "+opplFunction;
	}
	|
	LOOKAHEAD(3)
	variableNameToken= <VARIABLENAME> <COLON> variableType= <VARIABLETYPE>{
		try{
			Variable v =constraintSystem.createVariable(variableNameToken.image,VariableType.valueOfIgnoreCase(variableType.image));
			return v.toString();
		}catch(Exception e){
			throw new ParseException(e.getMessage(), e);
		}
	}
	|LOOKAHEAD(3)
	variableNameToken=<VARIABLENAME><DOT><RENDERINGVARIABLEATTRIBUTE>{
	return variableNameToken.image+"."+"RENDERING";
	}
	|LOOKAHEAD(3)
	variableNameToken=<VARIABLENAME><DOT><VALUESVARIABLEATTRIBUTE>{
	return variableNameToken.image+"."+"VALUES";
	}
	|LOOKAHEAD(3)
	variableNameToken=<VARIABLENAME><DOT><GROUPSVARIABLEATTRIBUTE><OPENPARENTHESYS>groupnumber=<INTEGER_LITERAL><CLOSEDPARENTHESYS>{
	return variableNameToken.image+"."+"GROUPS("+groupnumber.image+")";
	}
	| variableNameToken=<VARIABLENAME>{
		return variableNameToken.image;
	}
}


String opplFunction(String variableNameString, String variableTypeString, PatternConstraintSystem constraintSystem) #void:{
	Token opplFunctionNameToken;
	String variableExpression;
	String opplFunctionArgs;
	}
{
	LOOKAHEAD(1)
	   opplFunctionNameToken = <OPPLFUNCTION><OPENPARENTHESYS> opplFunctionArgs=opplFunctionArgs(constraintSystem)<CLOSEDPARENTHESYS>
	   {
	   		return opplFunctionNameToken.image+"("+opplFunctionArgs+")";
	   }
	  | variableExpression = variableExpression(constraintSystem)
		{
			return variableExpression;
		}
}


JAVACODE
String variableExpression(PatternConstraintSystem cs){
	String expression = org.coode.patterns.syntax.PatternUtils.readAndResolveString(this, cs, true, COMMA,ACTIONTOKENS);
	return expression;
}

JAVACODE
String opplFunctionArgs(PatternConstraintSystem constraintSystem){
	return org.coode.patterns.syntax.PatternUtils.readAndResolveString(this,constraintSystem, true, CLOSEDPARENTHESYS);
}

String resolveInnerPattern(PatternConstraintSystem constraintSystem) #void:{Token t;List<List<String>> args; PatternSignature signature = null;}
{
	<DOLLAR> t = <IDENTIFIER><OPENPARENTHESYS>{
		try{
			signature = new PatternSignature(t.image, getOWLOntologyManager(), this.modelFactory);
		}catch (PatternException e) {throw new ParseException(e.getMessage(), e);}
	}
	args=argList(signature) <CLOSEDPARENTHESYS>
		{
		String resolvedPattern;
		try {
			unresolvedString+="$"+t.image+"(";
			boolean first = true;
			for(List<String> anArgument: args){
				if(!first){unresolvedString+=", ";}else{first = false;}
				if(anArgument.size()==1){
					unresolvedString+=anArgument.iterator().next();
				}else{
					boolean firstSubArg= true;
					unresolvedString+="{";
					for(String subArg: anArgument){
						unresolvedString+=firstSubArg?subArg:", "+subArg;
						firstSubArg=firstSubArg?false:firstSubArg;
					}
				unresolvedString+="}";
			}
		}
		unresolvedString+=") ";
		String patternName = t.image;
		//visited.add(patternName);
		resolvedPattern = constraintSystem.resolvePattern(
				patternName,
				owlOntologyManager,
				this.visited,
				this.dependencies,
				args.toArray(new List[args.size()]));
	} catch (PatternException e) {throw new ParseException(e.getMessage(), e);}
	return resolvedPattern;
	}
}

List<List<String>> argList(PatternSignature signature) #void:{List<List<String>> toReturn = new ArrayList<List<String>>();List<String> anArgument=null; int i=0;}
{
	{
		this.completions.clear();
		try{
			this.completions.addAll(signature.getPossibleValues(i));
		}catch(Exception e){throw new ParseException(e.getMessage(), e);}
	}
	(anArgument =arg(i, signature)
		{
			i++;
			toReturn.add(anArgument);
			if(completions.size()==1 &&
				anArgument.size() ==1 &&
				completions.iterator().next().toString().equals(anArgument.iterator().next())){
				this.completions.clear();
				if(i>= signature.size()){
					this.completions.add(")");
				}else{
					this.completions.add(",");
				}
			}
		}
	(<COMMA> {
		this.completions.clear();
		try{
			this.completions.addAll(signature.getPossibleValues(i));
		}catch(Exception e){throw new ParseException(e.getMessage(), e);}}
	anArgument =arg(i, signature){
		i++;
		toReturn.add(anArgument);
		if(completions.size()==1
			&& anArgument.size() == 1
			&& completions.iterator().next().toString().equals(anArgument.iterator().next())){
			this.completions.clear();
			if(i>= signature.size()){
				this.completions.add(")");
			}else{
				this.completions.add(",");
			}
		}
	})*)?
	{return toReturn;}
}

List<String> arg(int i, PatternSignature signature) #void:{String t=null;List<String> toReturn=new ArrayList<String>();}
{
		t= argToken(i,signature){
		try{
			this.completions.clear();
			this.completions.addAll(signature.getPossibleValues(i, t));
		}catch(Exception e){throw new ParseException(e.getMessage(), e);}
		toReturn.add(t);
		return toReturn;
	}

	|<OPENCURLYBRACKETS>t = argToken(i,signature){
		toReturn.add(t);
	} (<COMMA> t = argToken(i,signature)
	{
		toReturn.add(t);
	})*<CLOSEDCURLYBRACKETS>{
		return toReturn;
	}
}

String argToken(int i, PatternSignature signature) #void :{Token t;}
{
	t =<VARIABLENAME>{
		return t.image;
	}
	| t = <INTEGER_LITERAL>{
		return t.image;
	}
	| t = <IDENTIFIER>{
		return t.image;
	}
	| <CREATESYMBOL> t = <IDENTIFIER>{
		String toCreate=t.image;
		try{
			return PatternParserUtils.create(getOWLOntologyManager(), toCreate, i, signature, modelFactory.getOPPLParser().getOPPLFactory());
		}catch(Exception e){throw new ParseException(e.getMessage(), e);}
	}
}

/*
Variable opplFunction(String name,VariableType type, PatternConstraintSystem constraintSystem) #void:
{	SingleValueGeneratedValue<String> value=null;
	AbstractCollectionGeneratedValue<? extends OWLObject> collection=null;
	SingleValueGeneratedVariable expressionVariable;
	SingleValueGeneratedValue<String> expression;
	Variable regexpVariable;
}
{
	<MATCH><OPENPARENTHESYS>expression=stringOperation(constraintSystem, true)<CLOSEDPARENTHESYS>
		{
		regexpVariable = regexpOperation(name, type, expression, constraintSystem);
		return regexpVariable;
		}
	|
	<CREATE><OPENPARENTHESYS>value = stringOperation(constraintSystem, true)<CLOSEDPARENTHESYS>
		{return constraintSystem.createStringGeneratedVariable(name,type, value);}
	|<CREATEINTERSECTION><OPENPARENTHESYS>collection = set(type,constraintSystem)<CLOSEDPARENTHESYS>
		{return constraintSystem.createIntersectionGeneratedVariable(name,type,(AbstractCollectionGeneratedValue<OWLClass>) collection);}
	|<CREATEUNION><OPENPARENTHESYS> collection = set(type,constraintSystem)<CLOSEDPARENTHESYS>
		{return constraintSystem.createUnionGeneratedVariable(name,type,(AbstractCollectionGeneratedValue<OWLClass>) collection);}
	| expressionVariable = expressionGeneratedVariable(name,type,constraintSystem)
		{return expressionVariable;}
}*/

JAVACODE
SingleValueGeneratedVariable expressionGeneratedVariable(String name,VariableType type, PatternConstraintSystem constraintSystem){
int beginningSubSection = token.beginColumn;
int beginningSubSectionLine = token.beginLine;
String expression = PatternUtils.readAndResolveString(this, constraintSystem, false, COMMA, ACTIONTOKENS);
try {
	return org.coode.oppl.syntax.Utils.parseVariableExpressionGeneratedVariable(name, type, expression, constraintSystem);
} catch (ParserException e) {
Exception temp=org.coode.oppl.syntax.Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
throw new ParseException(temp.getMessage(), temp);}
}

JAVACODE
Variable regexpOperation(String name,VariableType type, SingleValueGeneratedValue<String> expression, PatternConstraintSystem constraintSystem){
int beginningSubSection = token.beginColumn;
int beginningSubSectionLine = token.beginLine;

//try {
//	Pattern.compile(expression);
//} catch (PatternSyntaxException e) {
//Exception temp=org.coode.oppl.syntax.Utils.buildException(expression, beginningSubSection, beginningSubSectionLine, e);
//throw new ParseException(temp.getMessage(), temp);
//}
try {
	return org.coode.oppl.syntax.Utils.parseRegexpGeneratedVariable(name, type, expression, constraintSystem);
} catch (ParserException e) {
Exception temp=org.coode.oppl.syntax.Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
throw new ParseException(temp.getMessage(), temp);
}
}

AbstractCollectionGeneratedValue<? extends OWLObject> set(VariableType type,PatternConstraintSystem constraintSystem) #void:
{Token variableNameToken=null;}
{
	variableNameToken = <VARIABLENAME>"."<VALUESVARIABLEATTRIBUTE>
		{	String variableName = variableNameToken.image;
			Variable v = constraintSystem.getVariable(variableName);
			if (v != null) {
				if (type == v.getType()) {
					Attribute attribute = Attribute.VALUES;
					return AttributeFactory.getCollectionGeneratedValue(attribute, v, constraintSystem);
				} else {throw new ParseException("Type mismatch for variable " + v.getName() + ": type " + type + " needed instead of the actual " + v.getType());}
			} else {throw new ParseException("Invalid variable name: " + variableName);}
		}
}

SingleValueGeneratedValue<String> stringOperation(PatternConstraintSystem constraintSystem, boolean spacesAdded) #void:
{SingleValueGeneratedValue result=null;}
{
	result = stringConcat(constraintSystem, spacesAdded)
		{return result;}
}

SingleValueGeneratedValue<String> stringConcat(PatternConstraintSystem constraintSystem, boolean spacesAdded) #void:
{	SingleValueGeneratedValue aGeneratedValue;
	List<SingleValueGeneratedValue<String>> components = new ArrayList<SingleValueGeneratedValue<String>>();
}
{
	aGeneratedValue = generatedValue(constraintSystem, spacesAdded)
		{components.add(aGeneratedValue);}
	("+"  aGeneratedValue = generatedValue(constraintSystem, spacesAdded)
		{components.add(aGeneratedValue);}
	)*
		{if(components.size()==1){return aGeneratedValue;}else{return new ConcatGeneratedValues(components);}}
}

SingleValueGeneratedValue generatedValue(PatternConstraintSystem constraintSystem, boolean spacesAdded) #void:
{	String valueToken;
	Token variableNameToken;
	Token variableAttributeToken;
}
{
	<QUOTE>valueToken = readString(spacesAdded, constraintSystem)<QUOTE>
		{return new StringGeneratedValue(valueToken);}
	|LOOKAHEAD(4)
	variableNameToken = <IDENTIFIER>"." variableAttributeToken = <RENDERINGVARIABLEATTRIBUTE>
		{	String attributeString = variableAttributeToken.image;
			String variableName = variableNameToken.image;
			Variable v = constraintSystem.getVariable(variableName);
			if(v !=null){
				try {
					Attribute attribute = Attribute.valueOf(attributeString);
					return AttributeFactory.getVariableGeneratedValue(attribute, v, constraintSystem);
				} catch (IllegalArgumentException e) {throw new ParseException("Invalid attribute name: " + e.getMessage() + "; valid names are: " + Arrays.toString(Attribute.values()));}
		}else{throw new ParseException("Invalid variable name: "+variableName);}
		}
	|LOOKAHEAD(4)
	variableNameToken = <IDENTIFIER>"." <GROUPSVARIABLEATTRIBUTE><OPENPARENTHESYS> variableAttributeToken = <INTEGER_LITERAL><CLOSEDPARENTHESYS>
		{
		String attributeString = variableAttributeToken.image;
		String variableName = variableNameToken.image;
		Variable v = constraintSystem.getVariable(variableName);
		if (v != null) {
			int index = Integer.parseInt(attributeString);
			RegExpGenerated gv = (RegExpGenerated) v;
			Set<OWLObject> bindings = gv.getPossibleBindings();
			if (bindings.size() > 0) {
				VariableIndexGeneratedValue toReturn=new VariableIndexGeneratedValue(gv, index, bindings);
				return toReturn;
			}
			throw new ParseException("No matches found for variable: " + v);
		}else{throw new ParseException("Invalid variable name: "+variableName);}
		}
}

JAVACODE
String readString(boolean spacesAdded, PatternConstraintSystem cs){
return PatternUtils.readAndResolveString(this, cs, spacesAdded, QUOTE);
}


JAVACODE
OWLObject OWLExpression(Variable v, PatternConstraintSystem constraintSystem)
{
		Token t;
		String manSyntaxString="";
		while(true){
			t = getToken(1);
			if (t.kind==COMMA || t.kind ==CLOSEDCURLYBRACKETS || t.kind==SEMICOLON || t.kind==ACTIONTOKENS || t.kind==END || t.kind == EOF){
				break;
			}else{
				manSyntaxString += t.image+" ";
				t = getNextToken();
			}
		}
	manSyntaxString = manSyntaxString.trim();
	ExpressionParser expressionParser = new ExpressionParser(manSyntaxString, constraintSystem);
	try{
	OWLObject toReturn = v.accept(expressionParser);
	return toReturn;
	} catch(Exception e){throw new ParseException(e.getMessage(), e);}
}

VariableType variableType() #void:{Token t;}
{
	t = <VARIABLETYPE>
		{return VariableType.valueOfIgnoreCase(t.image);}
}


JAVACODE
OWLAxiom Clause(PatternConstraintSystem constraintSystem){
	int beginningSubSection = -1;
	int beginningSubSectionLine = -1;
	OWLAxiom toReturn =null;
	String manSyntaxString="";
	Token t;
		while(true){
			t = getToken(1);
			if (beginningSubSection < 0) {beginningSubSection = t.beginColumn;}
			if (beginningSubSectionLine < 0) {beginningSubSectionLine = t.beginLine;}
			if (t.kind==COMMA || t.kind==SEMICOLON || t.kind==ACTIONTOKENS || t.kind==END || t.kind == EOF){
				break;
			}else{
				manSyntaxString += t.image+" ";
				t = getNextToken();
			}
		}
	manSyntaxString = manSyntaxString.trim();
	VariableManchesterOWLSyntaxParser parser = new VariableManchesterOWLSyntaxParser(manSyntaxString, constraintSystem
					);
	//parser.setOWLEntityChecker(getOPPLFactory().getOWLEntityChecker());
	try{
		toReturn = parser.parseAxiom();

	}catch(ParserException e){
	Exception ex=org.coode.oppl.syntax.Utils.buildException(beginningSubSection, beginningSubSectionLine, e);
	throw new ParseException("OPPLParser.Clause() \"" + manSyntaxString + "\"\t" + ex.getMessage(), ex);
	}
return toReturn;
}




